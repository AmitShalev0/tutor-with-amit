<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sessions ‚Äì Amit Tutoring</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <style>
    .sessions-container {
      display: grid;
      gap: 2rem;
      margin-top: 1.5rem;
    }
    .session-section h3 {
      margin-bottom: 1rem;
      color: var(--accent);
    }
    .sessions-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--surface);
      border-radius: var(--radius-md);
      overflow: hidden;
    }
    .sessions-table th,
    .sessions-table td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    .sessions-table th {
      background: var(--surface-alt);
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .sessions-table tr:last-child td {
      border-bottom: none;
    }
    .sessions-table tr:hover {
      background: var(--surface-alt);
    }
    .session-actions {
      display: flex;
      gap: 0.5rem;
    }
    .session-actions button {
      padding: 0.25rem 0.75rem;
      font-size: 0.85rem;
    }
    .session-status {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 1rem;
      font-size: 0.8rem;
      font-weight: 600;
    }
    .status-upcoming {
      background: #dbeafe;
      color: #1e40af;
    }
    .status-past {
      background: #e5e7eb;
      color: #374151;
    }
    .status-pending {
      background: #fef3c7;
      color: #92400e;
    }
    .status-approved {
      background: #d1fae5;
      color: #065f46;
    }
    .status-pending_payment {
      background: #fef3c7;
      color: #92400e;
    }
    .status-succeed_payment {
      background: #d1fae5;
      color: #065f46;
    }
    .status-failed_payment {
      background: #fee2e2;
      color: #991b1b;
    }
    .status-payment_cancelled {
      background: #ede9fe;
      color: #5b21b6;
    }
    .status-payment_refunded {
      background: #cffafe;
      color: #0e7490;
    }
    .empty-state {
      text-align: center;
      padding: 3rem 1rem;
      color: var(--muted);
    }
    .notes-preview {
      max-width: 300px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .invoice-icon-button {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 1.25rem;
      line-height: 1;
      transition: transform 0.2s ease;
    }

    .invoice-icon-button:hover {
      transform: scale(1.1);
    }

    .invoice-icon-button[disabled] {
      opacity: 0.4;
      cursor: default;
      transform: none;
    }

    .invoice-placeholder {
      color: #6b7280;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
<div id="site-header"></div>
<script src="header-loader.js"></script>

<main class="container">
  <div class="flex-between mb-1">
    <div>
      <h2 class="m-0">Sessions</h2>
      <p class="mt-0-5rem">View all your past and upcoming tutoring sessions.</p>
    </div>
    <button class="btn primary" onclick="window.location.href='book.html'">Book Session</button>
  </div>

  <div class="sessions-container">
    <!-- Upcoming Sessions -->
    <div class="session-section">
      <h3>Upcoming Sessions</h3>
      <div id="upcoming-sessions-content">
        <p class="loading-text">Loading upcoming sessions...</p>
      </div>
    </div>

    <!-- Pending Sessions -->
    <div class="session-section">
      <h3>Pending Sessions</h3>
      <div id="pending-sessions-content">
        <p class="loading-text">Loading pending sessions...</p>
      </div>
    </div>

    <!-- Past Sessions -->
    <div class="session-section">
      <h3>Past Sessions</h3>
      <div id="past-sessions-content">
        <p class="loading-text">Loading past sessions...</p>
      </div>
    </div>
  </div>
</main>

<footer class="site-footer">
  <div class="container">
    <p>
      ¬© <span id="year"></span> Amit Tutoring ¬∑
      <a href="contact.html">Contact us</a>
    </p>
  </div>
  <script src="admin.js" defer></script>
</footer>

<!-- Firebase init -->
<script type="module" src="firebase-config.js"></script>

<!-- Sessions logic -->
<script type="module">
  // Wait for firebase-config.js to fully load
  function waitForFirebase() {
    return new Promise((resolve) => {
      if (window.firebaseAuth && window.firebaseDb) {
        resolve();
      } else {
        setTimeout(() => waitForFirebase().then(resolve), 100);
      }
    });
  }

  waitForFirebase().then(() => {
    // Use window globals that are already set up
    const auth = window.firebaseAuth;
    const db = window.firebaseDb;
    const onAuthStateChanged = window.firebaseOnAuth;
    const collection = window.firestoreCollection;
    const query = window.firestoreQuery;
    const where = window.firestoreWhere;
    const getDocs = window.firestoreGetDocs;
    const doc = window.firestoreDoc;
    const setDoc = window.firestoreSetDoc;
    const serverTimestamp = window.firestoreServerTimestamp;
    const getDoc = window.firestoreGetDoc;

    let currentUser = null;
    let allSessions = [];
    let feedbackCache = new Map();

    const ratingMetrics = [
      { key: 'overall', label: 'Overall experience', helper: 'How was the session overall?' },
      { key: 'clarity', label: 'Clarity of explanations', helper: 'Did the tutor explain concepts clearly?' },
      { key: 'helpfulness', label: 'Helpfulness', helper: 'Did the tutor address your questions?' },
      { key: 'engagement', label: 'Engagement', helper: 'Did the tutor keep you engaged?' },
      { key: 'pacing', label: 'Pacing', helper: 'Was the session pace comfortable?' }
    ];

    function getSessionKey(session) {
      return String(session?.id || session?.bookingId || session?.sessionId || '');
    }

    function findSessionByKey(sessionKey) {
      const normalized = String(sessionKey || '');
      return allSessions.find((s) => getSessionKey(s) === normalized);
    }

    function getTutorIdFromSession(session) {
      return (
        session?.tutorId ||
        session?.tutorUID ||
        session?.tutorUid ||
        session?.tutorUserId ||
        session?.primaryTutorId ||
        session?.primaryTutorUid ||
        null
      );
    }

    function getStudentIdFromSession(session) {
      return (
        session?.userId ||
        session?.studentId ||
        session?.studentUID ||
        session?.studentUserId ||
        session?.studentAccountId ||
        null
      );
    }

    function getSessionMode(session) {
      const raw = (
        session?.mode ||
        session?.deliveryMethod ||
        session?.sessionMode ||
        session?.sessionType ||
        session?.modality ||
        session?.location ||
        ''
      );
      const lowered = String(raw).toLowerCase();
      if (['in_person', 'in-person', 'inperson', 'in person', 'onsite'].includes(lowered)) return 'in_person';
      if (['online', 'virtual', 'remote', 'zoom', 'google meet'].includes(lowered)) return 'online';
      return 'online';
    }

    function clampRatingValue(value, fallback = 8) {
      const num = Number.parseInt(value, 10);
      if (!Number.isFinite(num)) return fallback;
      return Math.min(10, Math.max(1, num));
    }

    function sessionHasEnded(session) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const now = new Date();
      const sessionDate = getSessionDateForCompare(session?.sessionDate);
      if (!sessionDate) return false;
      if (sessionDate < today) return true;
      if (sessionDate.getTime() === today.getTime()) {
        if (session?.endTime) {
          const [hours, minutes] = session.endTime.split(':').map(Number);
          const sessionEnd = new Date();
          sessionEnd.setHours(hours || 0, minutes || 0, 0, 0);
          return now >= sessionEnd;
        }
        return true;
      }
      return false;
    }

    function canRateSession(session) {
      const sessionKey = getSessionKey(session);
      if (!sessionKey || !currentUser?.uid) return false;
      const studentId = getStudentIdFromSession(session);
      if (studentId && studentId !== currentUser.uid) return false;
      const normalizedStatus = normalizeBookingStatus(session?.status);
      const approvalStatus = normalizeApprovalStatus(session?.approvalStatus);
      const treatedAsSuccessful = normalizedStatus === 'succeed_payment' || approvalStatus === 'approved';
      if (!treatedAsSuccessful) return false;
      return sessionHasEnded(session);
    }

    // Check authentication
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "login.html";
        return;
      }
      currentUser = user;
      await loadSessions();
    });

  function base64ToUint8Array(base64) {
    if (!base64) {
      return new Uint8Array();
    }
    const clean = base64.replace(/\s/g, '');
    const binaryString = atob(clean);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }

  async function loadSessions() {
    try {
      console.log("Loading sessions for user:", currentUser.uid);
      
      // Fetch user's bookings from Firestore
      // Use "bookings" collection which contains pending requests
      const bookingsQuery = query(
        collection(db, "bookings"),
        where("userId", "==", currentUser.uid)
      );
      
      const querySnapshot = await getDocs(bookingsQuery);
      allSessions = [];
      
      console.log("Query snapshot size:", querySnapshot.size);
      
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        console.log("Booking data:", doc.id, data);
        allSessions.push({
          id: doc.id,
          ...data,
          // Keep the raw value; only convert Firestore Timestamps
          sessionDate: data.sessionDate && data.sessionDate.toDate
            ? data.sessionDate.toDate()
            : data.sessionDate
        });
      });

      console.log("Total sessions loaded:", allSessions.length);

      // Pull matching invoices so guardians see icons even if booking doc missed the url
      try {
        const invoicesQuery = query(
          collection(db, "invoices"),
          where("userId", "==", currentUser.uid)
        );
        const invoiceSnapshot = await getDocs(invoicesQuery);
        const invoicesByBooking = new Map();

        invoiceSnapshot.forEach((invoiceDoc) => {
          const invoiceData = invoiceDoc.data();
          const primaryKey = invoiceDoc.id;
          if (primaryKey) {
            invoicesByBooking.set(primaryKey, invoiceData);
          }
          if (invoiceData.bookingId && invoiceData.bookingId !== primaryKey) {
            invoicesByBooking.set(invoiceData.bookingId, invoiceData);
          }
        });

        if (invoicesByBooking.size) {
          allSessions = allSessions.map((session) => {
            const bookingKey = session.id || session.bookingId;
            const invoice = invoicesByBooking.get(bookingKey);
            if (!invoice) {
              return session;
            }
            return {
              ...session,
              invoiceStatus: invoice.status || session.invoiceStatus,
              invoicePdfUrl: invoice.invoicePdfUrl || session.invoicePdfUrl,
              invoicePdfBase64: invoice.invoicePdfBase64 || session.invoicePdfBase64,
              invoicePdfFileName: invoice.invoicePdfFileName || session.invoicePdfFileName,
              receiptPdfUrl: invoice.receiptPdfUrl || session.receiptPdfUrl,
              receiptPdfBase64: invoice.receiptPdfBase64 || session.receiptPdfBase64,
              receiptPdfFileName: invoice.receiptPdfFileName || session.receiptPdfFileName,
              receiptHtml: invoice.receiptHtml || session.receiptHtml
            };
          });
        }
      } catch (invoiceErr) {
        console.warn("Invoice lookup failed:", invoiceErr);
      }

      // Sort chronologically so downstream views stay in timeline order
      allSessions.sort(compareSessionsChronologically);

      displaySessions();
    } catch (err) {
      console.error("Error loading sessions:", err);
      
      // Show error message to user
      document.getElementById("upcoming-sessions-content").innerHTML = 
        `<div class="empty-state" style="color: #dc3545;">Error loading sessions: ${err.message}</div>`;
      document.getElementById("pending-sessions-content").innerHTML = 
        `<div class="empty-state">Unable to load data</div>`;
      document.getElementById("past-sessions-content").innerHTML = 
        `<div class="empty-state">Unable to load data</div>`;
    }
  }


  function getSessionDateForCompare(raw) {
    if (!raw) return null;

    // Firestore Timestamp
    if (raw.toDate) {
      const d = raw.toDate();
      d.setHours(0, 0, 0, 0);
      return d;
    }

    // Already a Date object
    if (raw instanceof Date) {
      const d = new Date(raw);
      d.setHours(0, 0, 0, 0);
      return d;
    }

    // "YYYY-MM-DD" string ‚Äì treat as local date
    if (typeof raw === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(raw)) {
      const [y, m, d] = raw.split('-').map(Number);
      return new Date(y, m - 1, d);
    }

    // Fallback
    const d = new Date(raw);
    d.setHours(0, 0, 0, 0);
    return d;
  }

  function timeStringToMinutesForSort(value) {
    if (!value || typeof value !== 'string') {
      return Number.MAX_SAFE_INTEGER;
    }
    const trimmed = value.trim();
    if (!trimmed) {
      return Number.MAX_SAFE_INTEGER;
    }
    const parts = trimmed.split(':');
    if (!parts.length) {
      return Number.MAX_SAFE_INTEGER;
    }
    const hours = Number(parts[0]);
    const minutes = parts.length > 1 ? Number(parts[1]) : 0;
    if (!Number.isFinite(hours) || !Number.isFinite(minutes)) {
      return Number.MAX_SAFE_INTEGER;
    }
    return hours * 60 + minutes;
  }

  function compareSessionsChronologically(a, b) {
    const dateA = getSessionDateForCompare(a.sessionDate);
    const dateB = getSessionDateForCompare(b.sessionDate);
    const dateMsA = dateA ? dateA.getTime() : Number.MAX_SAFE_INTEGER;
    const dateMsB = dateB ? dateB.getTime() : Number.MAX_SAFE_INTEGER;
    if (dateMsA !== dateMsB) {
      return dateMsA - dateMsB;
    }

    const startA = timeStringToMinutesForSort(a.startTime);
    const startB = timeStringToMinutesForSort(b.startTime);
    if (startA !== startB) {
      return startA - startB;
    }

    const fallbackA = String(a.id || a.bookingId || '');
    const fallbackB = String(b.id || b.bookingId || '');
    return fallbackA.localeCompare(fallbackB);
  }

  function normalizeBookingStatus(rawStatus) {
    if (!rawStatus) {
      return 'pending_payment';
    }
    const lowered = String(rawStatus).toLowerCase();
    const aliases = {
      pending: 'pending_payment',
      awaiting_payment: 'pending_payment',
      pending_payment: 'pending_payment',
      payment_pending: 'pending_payment',
      succeed_payment: 'succeed_payment',
      payment_succeed: 'succeed_payment',
      approved: 'succeed_payment',
      paid: 'succeed_payment',
      payment_success: 'succeed_payment',
      payment_succeeded: 'succeed_payment',
      failed_payment: 'failed_payment',
      payment_failed: 'failed_payment',
      payment_cancelled: 'payment_cancelled',
      payment_canceled: 'payment_cancelled',
      cancelled: 'payment_cancelled',
      canceled: 'payment_cancelled',
      rejected: 'payment_cancelled',
      refunded: 'payment_refunded',
      payment_refund: 'payment_refunded'
    };
    if (aliases[lowered]) {
      return aliases[lowered];
    }
    return lowered.replace(/[^a-z0-9_-]/g, '_');
  }

  function normalizeApprovalStatus(rawStatus) {
    if (!rawStatus) {
      return 'pending';
    }
    return String(rawStatus).toLowerCase();
  }

  function formatBookingStatusLabel(rawStatus) {
    const normalized = normalizeBookingStatus(rawStatus);
    const labels = {
      pending_payment: 'PAYMENT PENDING',
      succeed_payment: '[PAID]',
      failed_payment: 'Payment failed',
      payment_cancelled: 'Payment cancelled',
      payment_refunded: 'Payment refunded'
    };
    return labels[normalized] || (normalized ? normalized.replace(/_/g, ' ') : 'Unknown');
  }


  function displaySessions() {
    const now = new Date(); // Current date and time
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Start of today for date-only comparison
    
    console.log("Displaying sessions. Total:", allSessions.length);
    
    const pendingStatuses = new Set(['pending_payment']);
    const successfulStatuses = new Set(['succeed_payment']);
    const failedStatuses = new Set(['failed_payment']);
    const completedButNotSuccessfulStatuses = new Set(['payment_cancelled', 'payment_refunded']);
    const attentionStatuses = new Set(['failed_payment', 'payment_cancelled']);

    const pending = allSessions.filter((session) => {
      const normalizedStatus = normalizeBookingStatus(session.status);
      const approvalStatus = normalizeApprovalStatus(session.approvalStatus);
      if (approvalStatus === 'approved') {
        return false;
      }
      if (pendingStatuses.has(normalizedStatus)) {
        return true;
      }
      if (attentionStatuses.has(normalizedStatus)) {
        const sessionDate = getSessionDateForCompare(session.sessionDate);
        return !sessionDate || sessionDate >= today;
      }
      return false;
    });

    const upcoming = allSessions.filter((session) => {
      const normalizedStatus = normalizeBookingStatus(session.status);
      const approvalStatus = normalizeApprovalStatus(session.approvalStatus);
      const treatedAsSuccessful = successfulStatuses.has(normalizedStatus) || approvalStatus === 'approved';
      if (!treatedAsSuccessful) {
        return false;
      }
      const sessionDate = getSessionDateForCompare(session.sessionDate);
      if (!sessionDate) {
        return false;
      }
      if (sessionDate > today) {
        return true;
      }
      if (sessionDate.getTime() === today.getTime()) {
        if (session.endTime) {
          const [hours, minutes] = session.endTime.split(':').map(Number);
          const sessionEnd = new Date();
          sessionEnd.setHours(hours, minutes, 0, 0);
          return now < sessionEnd;
        }
        return true;
      }
      return false;
    });

    const past = allSessions.filter((session) => {
      const normalizedStatus = normalizeBookingStatus(session.status);
      const approvalStatus = normalizeApprovalStatus(session.approvalStatus);
      const treatedAsSuccessful = successfulStatuses.has(normalizedStatus) || approvalStatus === 'approved';
      const treatedAsCompleted = treatedAsSuccessful
        || failedStatuses.has(normalizedStatus)
        || completedButNotSuccessfulStatuses.has(normalizedStatus);
      if (!treatedAsCompleted) {
        return false;
      }
      const sessionDate = getSessionDateForCompare(session.sessionDate);
      if (!sessionDate) {
        return false;
      }
      if (sessionDate < today) {
        return true;
      }
      if (sessionDate.getTime() === today.getTime()) {
        if (session.endTime) {
          const [hours, minutes] = session.endTime.split(':').map(Number);
          const sessionEnd = new Date();
          sessionEnd.setHours(hours, minutes, 0, 0);
          return now >= sessionEnd;
        }
        return normalizedStatus !== 'payment_succeeded';
      }
      return false;
    });

    console.log("Categorized - Upcoming:", upcoming.length, "Pending:", pending.length, "Past:", past.length);

    const sortChronologically = (list) => list.sort(compareSessionsChronologically);
    sortChronologically(upcoming);
    sortChronologically(pending);
    sortChronologically(past);

    // Display upcoming sessions
    const upcomingContent = document.getElementById("upcoming-sessions-content");
    if (upcoming.length === 0) {
      upcomingContent.innerHTML = '<div class="empty-state">No upcoming sessions scheduled. <br> <a href="book.html">Book a session</a> to get started!</div>';
    } else {
      upcomingContent.innerHTML = `
        <table class="sessions-table">
          <thead>
            <tr>
              <th>Session Date</th>
              <th>Start & End Time</th>
              <th>Student Name</th>
              <th>Comments / Questions</th>
            </tr>
          </thead>
          <tbody>
            ${upcoming.map(session => renderUnifiedSessionRow(session)).join('')}
          </tbody>
        </table>
      `;
    }

    // Display pending sessions
    const pendingContent = document.getElementById("pending-sessions-content");
    if (pending.length === 0) {
      pendingContent.innerHTML = '<div class="empty-state">No pending sessions.</div>';
    } else {
      pendingContent.innerHTML = `
        <table class="sessions-table">
          <thead>
            <tr>
              <th>Session Date</th>
              <th>Start & End Time</th>
              <th>Student Name</th>
              <th>Comments / Questions</th>
            </tr>
          </thead>
          <tbody>
            ${pending.map(session => renderUnifiedSessionRow(session)).join('')}
          </tbody>
        </table>
      `;
    }

    // Display past sessions
    const pastContent = document.getElementById("past-sessions-content");
    if (past.length === 0) {
      pastContent.innerHTML = '<div class="empty-state">No past sessions yet.</div>';
    } else {
      pastContent.innerHTML = `
        <table class="sessions-table">
          <thead>
            <tr>
              <th>Session Date</th>
              <th>Start & End Time</th>
              <th>Student Name</th>
              <th>Comments / Questions</th>
              <th>Invoice</th>
              <th>Rate</th>
            </tr>
          </thead>
          <tbody>
            ${past.map(session => renderUnifiedSessionRow(session, { showInvoiceButton: true, showRateButton: true })).join('')}
          </tbody>
        </table>
      `;
    }
  }

  function formatSessionDate(value) {
    if (!value) return '-';

    if (value.toDate) {
      return value.toDate().toLocaleDateString();
    }
    if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
      const d = new Date(value + 'T00:00:00');
      return d.toLocaleDateString();
    }
    return new Date(value).toLocaleDateString();
  }


  function buildRatingPanelHtml(session) {
    const sessionKey = getSessionKey(session);
    const canRate = canRateSession(session);
    const disabledAttr = canRate ? '' : 'disabled';
    const helperText = canRate
      ? 'Ratings are private. Comments are shared with the tutor team only.'
      : 'Ratings unlock after the session is completed and paid.';

    const sliders = ratingMetrics.map(({ key, label, helper }) => `
      <div class="rating-slider" style="margin-bottom: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
          <label for="rating-${key}-${sessionKey}" style="font-weight: 600; color: #e5e7eb;">${label}</label>
          <span id="rating-${key}-value-${sessionKey}" style="font-size: 0.9rem; color: #9ca3af;">‚Äî</span>
        </div>
        <input type="range" id="rating-${key}-${sessionKey}" name="${key}" min="1" max="10" step="1" value="5" data-touched="false" ${disabledAttr} aria-label="${label}"
          oninput="handleRatingInput('${sessionKey}', '${key}', this.value)"
          style="width: 100%; margin: 6px 0;">
        <div style="font-size: 0.85rem; color: #9ca3af;">${helper}</div>
      </div>
    `).join('');

    return `
      <div class="rating-panel" style="padding: 16px 18px; border-top: 1px solid rgba(255,255,255,0.08);">
        <div style="font-weight: 700; color: #e5e7eb; margin-bottom: 12px;">Rate this session</div>
        <form id="rating-form-${sessionKey}" onsubmit="event.preventDefault(); submitRating('${sessionKey}');">
          ${sliders}
          <label for="rating-comment-${sessionKey}" style="display: block; font-weight: 600; color: #e5e7eb; margin-top: 4px;">Share a comment (optional)</label>
          <textarea id="rating-comment-${sessionKey}" name="comment" rows="3" maxlength="500" ${disabledAttr}
            placeholder="What went well? What can we improve?"
            style="width: 100%; margin-top: 6px; border-radius: 6px; padding: 10px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); color: #f5f5f7;"></textarea>
          <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-top: 12px;">
            <div style="font-size: 0.85rem; color: #9ca3af;">${helperText} (Max 500 characters)</div>
            <div style="display: flex; gap: 8px; align-items: center;">
              <button type="submit" class="btn primary" ${disabledAttr} title="${helperText}">Submit rating</button>
              <button type="button" class="btn tertiary" onclick="toggleRatingPanel('${sessionKey}')">Close</button>
            </div>
          </div>
          <div id="rating-status-${sessionKey}" style="margin-top: 8px; font-size: 0.9rem; color: #d1d5db;"></div>
        </form>
      </div>
    `;
  }


  function renderUnifiedSessionRow(session, options = {}) {
    const showInvoiceButton = options.showInvoiceButton === true;
    const showRateButton = options.showRateButton === true;
    const columnCount = 4 + (showInvoiceButton ? 1 : 0) + (showRateButton ? 1 : 0);
    const dateStr = formatSessionDate(session.sessionDate);
    const timeStr = session.startTime && session.endTime 
      ? `${session.startTime} - ${session.endTime}` 
      : session.startTime || 'TBD';
    const normalizedStatus = normalizeBookingStatus(session.status);
    const statusLabel = formatBookingStatusLabel(session.status);
    const statusBadge = `<span class="session-status status-${normalizedStatus}">${statusLabel}</span>`;
    let payButtonHtml = '';
    if (normalizedStatus === 'pending_payment') {
      const bookingIdentifier = session.id || session.bookingId;
      const amountCentsValue = Number(session.amountCents ?? session.amount_cents ?? 0);
      const hasValidAmount = Number.isFinite(amountCentsValue) && amountCentsValue > 0;
      if (bookingIdentifier && hasValidAmount) {
        const payParams = new URLSearchParams({
          bookingId: String(bookingIdentifier),
          amountCents: String(amountCentsValue),
          currency: String(session.currency || 'cad').toLowerCase()
        });
        const tutorUid = session.tutorId || session.tutorID || session.tutorUid || session.tutorUID;
        if (tutorUid) {
          payParams.set('tutorUid', tutorUid);
        }
        payButtonHtml = `<div style="margin-top: 0.5rem;"><a class="btn primary" href="pay.html?${payParams.toString()}">Pay Now</a></div>`;
      }
    }
    const timeWithStatusHtml = `
      <div>${timeStr}</div>
      <div style="margin-top: 0.35rem;">${statusBadge}</div>
      ${payButtonHtml}
    `;
    const students = session.studentName || session.studentNames || session.students || 'N/A';
    
    // Student's questions/comments from booking form
    const studentComments = session.comments || session.notes || session.additionalComments || '';
    const studentCommentsHtml = studentComments 
      ? `<div style="white-space: pre-wrap; font-size: 0.9rem; line-height: 1.5;">${studentComments}</div>`
      : '<div style="color: #b0b0b5; font-style: italic;"></div>';
    
    // Tutor's session notes (separate from student comments)
    const tutorNotes = session.sessionSummary || '';
    const hasTutorNotes = tutorNotes.trim().length > 0;
    
    const tutorNotesHtml = hasTutorNotes ? `
      <div style="margin-top: 8px; padding: 12px; background: rgba(79, 157, 255, 0.1); border-left: 3px solid #4f9dff; border-radius: 4px;">
        <div style="font-weight: 600; color: #4f9dff; font-size: 0.85rem; margin-bottom: 6px;">üìù Session Notes from Tutor:</div>
        <div style="white-space: pre-wrap; font-size: 0.9rem; line-height: 1.5; color: #f5f5f7;">${tutorNotes}</div>
      </div>
    ` : '<div style="color: #b0b0b5; font-style: italic; padding: 12px;">No tutor notes yet</div>';

    const sessionKey = getSessionKey(session);

    let invoiceCellHtml = '';
    if (showInvoiceButton) {
      const iconButtons = [];
      const sessionLookupId = String(session.id || session.bookingId || '');
      const safeLookupId = sessionLookupId
        .replace(/\\/g, '\\\\')
        .replace(/'/g, "\\'")
        .replace(/"/g, '\\"');
      const hasInvoiceDoc = Boolean(session.invoicePdfUrl || session.invoicePdfBase64);
      const hasReceiptDoc = Boolean(session.receiptPdfUrl || session.receiptPdfBase64);

      if (hasInvoiceDoc) {
        iconButtons.push(`<button class="invoice-icon-button" title="View invoice PDF" onclick="event.stopPropagation(); openSessionDocument('${safeLookupId}', 'invoice')">üßæ</button>`);
      }
      if (hasReceiptDoc) {
        iconButtons.push(`<button class="invoice-icon-button" title="View payment receipt" onclick="event.stopPropagation(); openSessionDocument('${safeLookupId}', 'receipt')">üìÑ</button>`);
      }

      invoiceCellHtml = iconButtons.length
        ? `<td class="invoice-cell">${iconButtons.join(' ')}</td>`
        : '<td class="invoice-cell"><span class="invoice-placeholder">‚Äî</span></td>';
    }

    let rateCellHtml = '';
    if (showRateButton) {
      const canRate = canRateSession(session);
      const label = feedbackCache.has(sessionKey) ? 'Edit rating' : 'Rate';
      const content = sessionKey
        ? `<button class="btn secondary" data-rate-key="${sessionKey}" onclick="event.stopPropagation(); toggleRatingPanel('${sessionKey}')" ${canRate ? '' : 'disabled title="Ratings are available after the session is completed and paid."'}>${label}</button>`
        : '<span class="invoice-placeholder">‚Äî</span>';
      rateCellHtml = `<td class="invoice-cell">${content}</td>`;
    }

    return `
      <tr style="cursor: pointer;" onclick="toggleTutorNotes('${session.id}')" title="Click to ${hasTutorNotes ? 'view' : 'see'} tutor notes">
        <td>${dateStr}</td>
        <td>${timeWithStatusHtml}</td>
        <td>${students}</td>
        <td>${studentCommentsHtml}</td>
        ${invoiceCellHtml}
        ${rateCellHtml}
      </tr>
      <tr id="rating-row-${sessionKey}" style="display: none;">
        <td colspan="${columnCount}" style="background: rgba(24, 32, 56, 0.6); padding: 0;">
          ${buildRatingPanelHtml(session)}
        </td>
      </tr>
      <tr id="tutor-notes-row-${session.id}" style="display: none;">
        <td colspan="${columnCount}" style="background: rgba(0, 0, 0, 0.2); padding: 0;">
          ${tutorNotesHtml}
        </td>
      </tr>
    `;
  }

  window.toggleTutorNotes = function(sessionId) {
    closeAllRatingPanels();
    const row = document.getElementById(`tutor-notes-row-${sessionId}`);
    if (row) {
      row.style.display = row.style.display === 'none' ? 'table-row' : 'none';
    }
  };

  function closeAllRatingPanels() {
    document.querySelectorAll('[id^="rating-row-"]').forEach((el) => {
      el.style.display = 'none';
    });
  }

  function closeRatingPanel(sessionKey) {
    const row = document.getElementById(`rating-row-${sessionKey}`);
    if (row) {
      row.style.display = 'none';
    }
  }

  window.toggleRatingPanel = async function(sessionKey) {
    if (!sessionKey) return;
    const row = document.getElementById(`rating-row-${sessionKey}`);
    if (!row) return;
    const rateBtn = document.querySelector(`button[data-rate-key="${sessionKey}"]`);
    const isLocked = rateBtn?.dataset?.locked === 'true';
    const isHidden = row.style.display === 'none';
    // Hide other open panels to reduce clutter
    document.querySelectorAll('[id^="rating-row-"]').forEach((el) => {
      if (el !== row) el.style.display = 'none';
    });
    if (isLocked && !isHidden) {
      row.style.display = 'none';
      return;
    }
    if (isLocked && isHidden) {
      // When locked, pressing the Rated button should simply retract (no open)
      return;
    }
    row.style.display = isHidden ? 'table-row' : 'none';
    if (isHidden) {
      await populateRatingForm(sessionKey);
    }
  };

  function disableRatingForm(sessionKey, message) {
    const form = document.getElementById(`rating-form-${sessionKey}`);
    const statusEl = document.getElementById(`rating-status-${sessionKey}`);
    const rateBtn = document.querySelector(`button[data-rate-key="${sessionKey}"]`);
    if (form) {
      form.querySelectorAll('input[type="range"], textarea, button[type="submit"]').forEach((el) => {
        el.disabled = true;
        el.setAttribute('aria-disabled', 'true');
      });
    }
    if (statusEl && message) {
      statusEl.textContent = message;
    }
    if (rateBtn) {
      rateBtn.textContent = 'Rated';
      rateBtn.title = 'Thanks for submitting your rating.';
      rateBtn.dataset.locked = 'true';
    }
  }

  function handleRatingInput(sessionKey, key, rawValue) {
    const clamped = clampRatingValue(rawValue, NaN);
    const input = document.getElementById(`rating-${key}-${sessionKey}`);
    if (input) {
      input.dataset.touched = 'true';
      if (Number.isFinite(clamped)) {
        input.value = clamped;
      }
    }
    const valueEl = document.getElementById(`rating-${key}-value-${sessionKey}`);
    if (valueEl) {
      valueEl.textContent = Number.isFinite(clamped) ? clamped : '‚Äî';
    }
  }
  window.handleRatingInput = handleRatingInput;

  function setRatingFieldValue(sessionKey, key, value) {
    const clamped = clampRatingValue(value, NaN);
    const input = document.getElementById(`rating-${key}-${sessionKey}`);
    if (input && Number.isFinite(clamped)) {
      input.value = clamped;
      input.dataset.touched = 'true';
      const valueEl = document.getElementById(`rating-${key}-value-${sessionKey}`);
      if (valueEl) valueEl.textContent = clamped;
    }
  }

  function resetRatingField(sessionKey, key) {
    const input = document.getElementById(`rating-${key}-${sessionKey}`);
    if (input) {
      input.dataset.touched = 'false';
      input.value = 5;
    }
    const valueEl = document.getElementById(`rating-${key}-value-${sessionKey}`);
    if (valueEl) valueEl.textContent = '‚Äî';
  }

  async function populateRatingForm(sessionKey) {
    const session = findSessionByKey(sessionKey);
    const form = document.getElementById(`rating-form-${sessionKey}`);
    const statusEl = document.getElementById(`rating-status-${sessionKey}`);
    const commentEl = document.getElementById(`rating-comment-${sessionKey}`);
    const rateBtn = document.querySelector(`button[data-rate-key="${sessionKey}"]`);
    if (!session || !form || !statusEl) return;

    if (!canRateSession(session)) {
      statusEl.textContent = 'Ratings unlock after the session is completed and paid.';
      form.querySelectorAll('input, textarea, button[type="submit"]').forEach((el) => {
        el.disabled = true;
      });
      return;
    }

    form.querySelectorAll('input, textarea, button[type="submit"]').forEach((el) => {
      el.disabled = false;
    });

    statusEl.textContent = 'Loading saved rating...';
    let feedback = feedbackCache.get(sessionKey);
    try {
      if (!feedback) {
        const snap = await getDoc(doc(db, 'sessionFeedback', sessionKey));
        if (snap.exists()) {
          feedback = { id: snap.id, ...snap.data() };
          feedbackCache.set(sessionKey, feedback);
        }
      }
    } catch (err) {
      console.error('Failed to load feedback', err);
      statusEl.textContent = 'Unable to load your previous rating. You can still submit a new one.';
    }

    if (feedback?.ratings) {
      ratingMetrics.forEach(({ key }) => setRatingFieldValue(sessionKey, key, feedback.ratings[key]));
    } else {
      ratingMetrics.forEach(({ key }) => resetRatingField(sessionKey, key));
    }
    if (feedback && commentEl) {
      commentEl.value = feedback.comment || '';
    } else if (commentEl) {
      commentEl.value = '';
    }

    if (feedback) {
      disableRatingForm(sessionKey, 'Thank you for rating! This session is locked.');
    } else {
      statusEl.textContent = 'Slide to rate from 1-10. Higher = better. All 5 ratings are required.';
    }
  }

  async function recomputeTutorStats(tutorId) {
    if (!tutorId) return;
    try {
      const statsQuery = query(
        collection(db, 'sessionFeedback'),
        where('tutorId', '==', tutorId),
        where('status.submitted', '==', true)
      );
      const snap = await getDocs(statsQuery);
      const sums = { overall: 0, clarity: 0, helpfulness: 0, engagement: 0, pacing: 0 };
      const studentIds = new Set();
      let ratingCount = 0;

      snap.forEach((docSnap) => {
        const data = docSnap.data() || {};
        const status = data.status || {};
        if (status.reported || status.deletedByTutor) return;
        const ratings = data.ratings || {};
        ratingCount += 1;
        const studentId = data.studentId || data.userId;
        if (studentId) studentIds.add(String(studentId));
        ratingMetrics.forEach(({ key }) => {
          const val = clampRatingValue(ratings[key], NaN);
          if (Number.isFinite(val)) {
            sums[key] = (sums[key] || 0) + val;
          }
        });
      });

      const statsDoc = {
        ratingCount,
        distinctStudentCount: studentIds.size,
        updatedAt: serverTimestamp()
      };

      ratingMetrics.forEach(({ key }) => {
        const sum = sums[key] || 0;
        const avg = ratingCount ? sum / ratingCount : 0;
        const fieldName = `avg${key.charAt(0).toUpperCase()}${key.slice(1)}`;
        statsDoc[fieldName] = Number(avg.toFixed(2));
      });

      await setDoc(doc(db, 'tutorStats', tutorId), statsDoc, { merge: true });
    } catch (err) {
      console.error('Failed to refresh tutor stats', err);
    }
  }

  window.submitRating = async function(sessionKey) {
    const session = findSessionByKey(sessionKey);
    const form = document.getElementById(`rating-form-${sessionKey}`);
    const statusEl = document.getElementById(`rating-status-${sessionKey}`);
    const submitBtn = form ? form.querySelector('button[type="submit"]') : null;
    const commentEl = document.getElementById(`rating-comment-${sessionKey}`);
    const rateBtn = document.querySelector(`button[data-rate-key="${sessionKey}"]`);

    if (!session || !form || !statusEl) return;
    if (!canRateSession(session)) {
      statusEl.textContent = 'Ratings unlock after the session is completed and paid.';
      return;
    }

    const ratings = {};
    let missingRating = false;
    ratingMetrics.forEach(({ key }) => {
      const input = document.getElementById(`rating-${key}-${sessionKey}`);
      const touched = input?.dataset?.touched === 'true';
      const value = clampRatingValue(input ? input.value : undefined, NaN);
      if (!touched || !Number.isFinite(value)) {
        missingRating = true;
      }
      ratings[key] = touched && Number.isFinite(value) ? value : null;
    });

    if (missingRating) {
      statusEl.textContent = 'Please set all 5 ratings before submitting.';
      if (submitBtn) submitBtn.disabled = false;
      return;
    }

    const rawComment = (commentEl?.value || '').trim();
    if (rawComment.length > 500) {
      statusEl.textContent = 'Comments must be 500 characters or less.';
      return;
    }

    statusEl.textContent = 'Saving rating...';
    if (submitBtn) submitBtn.disabled = true;

    let existing = feedbackCache.get(sessionKey);
    try {
      if (!existing) {
        const snap = await getDoc(doc(db, 'sessionFeedback', sessionKey));
        if (snap.exists()) {
          existing = { id: snap.id, ...snap.data() };
          feedbackCache.set(sessionKey, existing);
        }
      }
    } catch (err) {
      console.error('Failed to check existing feedback', err);
    }

    const tutorId = getTutorIdFromSession(session);
    const studentId = getStudentIdFromSession(session) || currentUser?.uid || null;
    const baseStatus = existing?.status || {};
    const payload = {
      sessionKey,
      sessionId: session.sessionId || session.id || session.bookingId || sessionKey,
      bookingId: session.bookingId || session.id || null,
      tutorId: tutorId || null,
      tutorName: session.tutorName || session.tutor || '',
      studentId,
      studentFirstName: session.studentFirstName || (session.studentName ? String(session.studentName).split(' ')[0] : ''),
      studentName: session.studentName || '',
      mode: getSessionMode(session),
      ratings,
      comment: rawComment,
      status: {
        submitted: true,
        shared: baseStatus.shared === true,
        reported: baseStatus.reported === true,
        deletedByTutor: baseStatus.deletedByTutor === true
      },
      updatedAt: serverTimestamp()
    };

    if (!existing?.createdAt) {
      payload.createdAt = serverTimestamp();
    }

    try {
      await setDoc(doc(db, 'sessionFeedback', sessionKey), payload, { merge: true });
      feedbackCache.set(sessionKey, payload);
      disableRatingForm(sessionKey, 'Thanks! Your rating was submitted.');
      await recomputeTutorStats(tutorId);
    } catch (err) {
      console.error('Failed to save rating', err);
      statusEl.textContent = 'Unable to save rating. Please try again.';
    } finally {
      if (submitBtn) submitBtn.disabled = false;
    }
  };

  window.openSessionDocument = function(sessionKey, kind) {
    if (!sessionKey) {
      alert('This document is not available yet.');
      return;
    }

    const normalizedKey = String(sessionKey);
    const session = allSessions.find((s) => String(s.id) === normalizedKey || String(s.bookingId) === normalizedKey);
    if (!session) {
      alert('This document is not available yet.');
      return;
    }

    const isInvoice = kind === 'invoice';
    const docUrl = isInvoice ? (session.invoicePdfUrl || null) : (session.receiptPdfUrl || null);
    const docBase64 = isInvoice ? (session.invoicePdfBase64 || null) : (session.receiptPdfBase64 || null);
    const defaultName = `${isInvoice ? 'invoice' : 'receipt'}-${normalizedKey}.pdf`;
    const fileName = isInvoice
      ? (session.invoicePdfFileName || defaultName)
      : (session.receiptPdfFileName || defaultName);

    if (docUrl) {
      window.open(docUrl, '_blank', 'noopener');
      return;
    }

    if (!docBase64) {
      alert('This document is not available yet.');
      return;
    }

    try {
      const pdfBytes = base64ToUint8Array(docBase64);
      if (!pdfBytes.length) {
        alert('This document is not available yet.');
        return;
      }

      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      const blobUrl = URL.createObjectURL(blob);
      const newWindow = window.open(blobUrl, '_blank', 'noopener');

      if (!newWindow) {
        const link = document.createElement('a');
        link.href = blobUrl;
        link.target = '_blank';
        link.rel = 'noopener';
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      setTimeout(() => URL.revokeObjectURL(blobUrl), 60 * 1000);
    } catch (err) {
      console.error('Unable to open PDF content:', err);
      alert('Unable to open this document.');
    }
  };

  function editSession(session) {
    // Redirect to edit booking page
    window.location.href = `edit-booking.html?id=${session.id}`;
  }

  async function removeSession(session) {
    const dateStr = formatSessionDate(session.sessionDate);

    // const sessionDate = new Date(session.sessionDate);
    // const dateStr = formatSessionDate(sessionDate);
    // const dateStr = sessionDate.toLocaleDateString('en-US', { 
    //   weekday: 'long', 
    //   year: 'numeric', 
    //   month: 'long', 
    //   day: 'numeric' 
    // });
    
    if (!confirm(`Are you sure you want to cancel the session on ${dateStr} at ${session.startTime}?\n\nThis action cannot be undone.`)) {
      return;
    }

    try {
      const deleteDoc = window.firestoreDeleteDoc;
      const doc = window.firestoreDoc;
      
      // Delete from Firestore bookings collection
      await deleteDoc(doc(db, "bookings", session.id));
      
      // Remove from local array
      allSessions = allSessions.filter(s => s.id !== session.id);
      
      // Refresh display
      displaySessions();
      
      alert('Session cancelled successfully!');
    } catch (err) {
      console.error("Error removing session:", err);
      alert('Failed to cancel session. Please try again or contact support.');
    }
  }

  }); // End waitForFirebase promise

</script>
</body>
</html>

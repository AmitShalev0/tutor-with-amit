<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Find a Tutor – Amit Tutoring</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <style>
    main {
      max-width: 1040px;
      margin: 0 auto;
      padding: 2rem 0 4rem;
    }
    .search-hero {
      text-align: center;
      margin-bottom: 2.5rem;
    }
    .search-hero h1 {
      font-size: 2.2rem;
      margin-bottom: 0.75rem;
    }
    .search-controls {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      margin-bottom: 2rem;
      background: rgba(30, 41, 59, 0.7);
      padding: 1.5rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.15);
    }
    .search-controls label {
      display: block;
      font-weight: 500;
      margin-bottom: 0.4rem;
    }
    .search-controls input[type="text"],
    .search-controls select {
      width: 100%;
      border-radius: 0.5rem;
      border: 1px solid #334155;
      background: #0f172a;
      color: #f8fafc;
      padding: 0.6rem 0.75rem;
      box-sizing: border-box;
    }
    .mode-filters {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 0.25rem;
    }
    .mode-filters label {
      font-weight: 400;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }
    #tutor-results {
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }
    .tutor-card {
      background: #0f172a;
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.2);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .tutor-card-header {
      display: flex;
      gap: 1rem;
      align-items: center;
    }
    .tutor-card-avatar {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      border: 2px solid rgba(96, 165, 250, 0.3);
      background: rgba(15, 23, 42, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      flex-shrink: 0;
    }
    .tutor-card-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .tutor-card-avatar span {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      color: #bfdbfe;
    }
    .tutor-card-header-body {
      flex: 1;
      min-width: 0;
    }
    .tutor-card-header.toggleable {
      cursor: pointer;
      position: relative;
    }
    .tutor-card-header.toggleable:focus-visible {
      outline: 2px solid #38bdf8;
      outline-offset: 4px;
    }
    .tutor-card-header.toggleable::after {
      content: 'v';
      margin-left: auto;
      color: #94a3b8;
      font-size: 0.9rem;
      transition: transform 0.2s ease;
    }
    .tutor-card.bio-open .tutor-card-header.toggleable::after {
      transform: rotate(180deg);
    }
    .tutor-card-bio {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 0.75rem;
      padding: 0.9rem 1rem;
      font-size: 0.95rem;
      color: #e2e8f0;
      line-height: 1.45;
    }
    .tutor-card-bio p {
      margin: 0;
    }
    .tutor-card-bio .read-more-link {
      display: inline-block;
      margin-top: 0.65rem;
      color: #38bdf8;
      font-weight: 600;
    }
    .tutor-card-bio .read-more-link:hover {
      text-decoration: underline;
    }
    .tutor-card h2 {
      font-size: 1.35rem;
      margin: 0;
    }
    .headline {
      color: #cbd5f5;
      font-size: 1rem;
      margin: 0;
    }
    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .tag {
      background: rgba(59, 130, 246, 0.15);
      color: #bfdbfe;
      border-radius: 999px;
      padding: 0.2rem 0.75rem;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .detail-text {
      font-size: 0.95rem;
      color: #e2e8f0;
      line-height: 1.4;
    }
    .location-detail a {
      color: #38bdf8;
      text-decoration: underline;
      display: inline-block;
      margin-top: 0.25rem;
      font-size: 0.85rem;
    }
    .empty-state {
      text-align: center;
      padding: 3rem 1rem;
      border-radius: 1rem;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }
    .error-state {
      color: #fecaca;
      text-align: center;
      margin-top: 1rem;
    }
    .tutor-card .btn {
      align-self: flex-start;
    }
    .tutor-card-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-top: 1rem;
    }
    .favorite-btn {
      background: rgba(59, 130, 246, 0.18);
      color: #bfdbfe;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }
    .favorite-btn.is-favourite {
      background: rgba(251, 191, 36, 0.22);
      color: #facc15;
      border-color: rgba(250, 204, 21, 0.45);
    }
    .favorite-btn:disabled {
      opacity: 0.65;
      cursor: wait;
    }
    .map-section {
      margin-bottom: 2.5rem;
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 1rem;
      padding: 1.5rem;
      display: grid;
      gap: 1rem;
    }
    .map-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: flex-end;
    }
    .map-search-group {
      flex: 1 1 280px;
      min-width: 240px;
    }
    .map-search-group label {
      display: block;
      font-weight: 500;
      margin-bottom: 0.4rem;
    }
    .map-search-controls {
      display: flex;
      gap: 0.75rem;
    }
    .map-search-controls input[type="text"] {
      flex: 1 1 auto;
      border-radius: 0.6rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.9);
      color: #f8fafc;
      padding: 0.6rem 0.75rem;
    }
    .map-display-modes {
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 0.75rem;
      padding: 0.75rem 1rem;
      display: flex;
      gap: 1rem;
      align-items: center;
      color: #cbd5f5;
    }
    .map-display-modes legend {
      padding: 0 0.4rem;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #94a3b8;
    }
    .map-display-modes label {
      display: inline-flex;
      gap: 0.35rem;
      align-items: center;
      cursor: pointer;
      font-weight: 400;
    }
    .tutor-map {
      width: 100%;
      height: 420px;
      border-radius: 0.75rem;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div id="site-header"></div>
  <script src="header-loader.js"></script>

  <main class="container">
    <section class="search-hero">
      <h1>Find the Right Tutor</h1>
      <p>Browse verified profiles, meeting formats, and subjects before you book.</p>
    </section>

    <section class="search-controls" aria-label="Tutor filters">
      <div>
        <label for="search-query">Search by name or subject</label>
        <input type="text" id="search-query" placeholder="e.g. Physics, Jane" autocomplete="off" />
      </div>
      <div>
        <label for="grade-filter">Grade level</label>
        <input type="text" id="grade-filter" placeholder="e.g. IB, Grade 11" autocomplete="off" />
      </div>
      <div>
        <label>Meeting format</label>
        <div class="mode-filters">
          <label><input type="checkbox" id="filter-online" /> Online</label>
          <label><input type="checkbox" id="filter-inperson" /> In person</label>
        </div>
      </div>
    </section>

    <section class="map-section" aria-label="Tutor travel map">
      <div class="map-toolbar">
        <div class="map-search-group">
          <label for="postal-search">Center map on a postal code</label>
          <div class="map-search-controls">
            <input id="postal-search" type="text" placeholder="e.g. T2P 1A1" autocomplete="postal-code" />
            <button id="postal-search-button" class="btn secondary" type="button">Center map</button>
          </div>
        </div>
        <fieldset class="map-display-modes">
          <legend>Display</legend>
          <label><input type="radio" name="map-display-mode" value="markers" checked /> Markers only</label>
          <label><input type="radio" name="map-display-mode" value="radius" /> Include travel radius</label>
        </fieldset>
      </div>
      <div id="tutor-map" class="tutor-map"></div>
      <p id="map-error" class="error-state" hidden></p>
    </section>

    <section id="results-container">
      <div id="loading-state" class="detail-text">Loading tutors...</div>
      <div id="tutor-results" hidden></div>
      <div id="empty-state" class="empty-state" hidden>
        <h2>No tutors match your filters yet.</h2>
        <p>Try clearing your filters or reach out via the contact page for a personal recommendation.</p>
      </div>
      <p id="error-state" class="error-state" hidden></p>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p>
        © <span id="year"></span> Amit Tutoring ·
        <a href="contact.html">Contact me</a>
      </p>
    </div>
    <script src="main.js"></script>
  </footer>

  <script type="module" src="firebase-config.js"></script>
  <script type="module">
    import { loadGoogleMapsApi } from './maps-utils.js';

    const db = window.firebaseDb;
    const collection = window.firestoreCollection;
    const query = window.firestoreQuery;
    const where = window.firestoreWhere;
    const getDocs = window.firestoreGetDocs;
    const functionsBase = window.firebaseFunctionsBase;
    const auth = window.firebaseAuth;
    const onAuth = window.firebaseOnAuth;
    const docFn = window.firestoreDoc;
    const getDocFn = window.firestoreGetDoc;
    const updateDocFn = window.firestoreUpdateDoc;
    const setDocFn = window.firestoreSetDoc;
    const arrayUnion = window.firestoreArrayUnion;
    const arrayRemove = window.firestoreArrayRemove;

    const searchInput = document.getElementById('search-query');
    const gradeInput = document.getElementById('grade-filter');
    const filterOnline = document.getElementById('filter-online');
    const filterInPerson = document.getElementById('filter-inperson');
    const loadingState = document.getElementById('loading-state');
    const resultsGrid = document.getElementById('tutor-results');
    const emptyState = document.getElementById('empty-state');
    const errorState = document.getElementById('error-state');
    const mapContainer = document.getElementById('tutor-map');
    const mapError = document.getElementById('map-error');
    const postalSearchInput = document.getElementById('postal-search');
    const postalSearchButton = document.getElementById('postal-search-button');
    const mapDisplayRadios = Array.from(document.querySelectorAll('input[name="map-display-mode"]'));

    let allTutors = [];
    let currentUser = null;
    let favoriteTutorIds = new Set();
    let favoriteButtons = new Map();
    const favoriteMutations = new Set();
    const placeCache = new Map();
    const inflightPlaces = new Map();
    const defaultCenter = { lat: 51.0447, lng: -114.0719 };
    const mapsApiPromise = loadGoogleMapsApi({ libraries: 'places' });
    let mapsApi = null;
    let map = null;
    let geocoder = null;
    let infoWindow = null;
    let markers = [];
    let circles = [];
    let lastMapTutors = [];
    let mapMode = 'markers';

    async function loadUserFavorites(uid) {
      if (!uid || !docFn || !getDocFn) {
        favoriteTutorIds = new Set();
        refreshAllFavoriteButtons();
        return;
      }
      try {
        const userSnap = await getDocFn(docFn(db, 'users', uid));
        if (userSnap.exists()) {
          const data = userSnap.data() || {};
          const ids = Array.isArray(data.favoriteTutorIds) ? data.favoriteTutorIds.filter(Boolean) : [];
          favoriteTutorIds = new Set(ids);
        } else {
          favoriteTutorIds = new Set();
        }
      } catch (error) {
        console.warn('Failed to load favourite tutors', error);
        favoriteTutorIds = new Set();
      }
      refreshAllFavoriteButtons();
    }

    function updateFavoriteButtonState(tutorId) {
      const button = favoriteButtons.get(tutorId);
      if (!button) {
        return;
      }
      const isFavourite = favoriteTutorIds.has(tutorId);
      button.textContent = isFavourite ? '★ Favourite' : '☆ Favourite';
      button.classList.toggle('is-favourite', isFavourite);
      button.disabled = favoriteMutations.has(tutorId);
      button.title = currentUser
        ? (isFavourite ? 'Remove from favourites' : 'Add to favourites')
        : 'Sign in to save favourite tutors';
    }

    function refreshAllFavoriteButtons() {
      favoriteButtons.forEach((_, tutorId) => updateFavoriteButtonState(tutorId));
    }

    function createFavoriteButton(tutorId) {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'btn secondary favorite-btn';
      button.dataset.favoriteBtn = tutorId;
      button.addEventListener('click', () => handleFavoriteClick(tutorId));
      favoriteButtons.set(tutorId, button);
      updateFavoriteButtonState(tutorId);
      return button;
    }

    function handleBookClick(tutorId) {
      const target = tutorId ? `book.html?tutor=${encodeURIComponent(tutorId)}` : 'book.html';
      window.location.href = target;
    }

    async function handleFavoriteClick(tutorId) {
      if (!currentUser) {
        window.location.href = 'login.html';
        return;
      }
      if (favoriteMutations.has(tutorId)) {
        return;
      }

      if (!tutorId) {
        console.warn('Favourite toggle skipped: missing tutorId');
        return;
      }

      if (!docFn || !updateDocFn || !arrayUnion || !arrayRemove) {
        alert('Favourite tutors are unavailable right now. Please try again later.');
        return;
      }

      favoriteMutations.add(tutorId);
      updateFavoriteButtonState(tutorId);

      try {
        const userRef = docFn(db, 'users', currentUser.uid);
        const isFavourite = favoriteTutorIds.has(tutorId);
        const payload = isFavourite
          ? { favoriteTutorIds: arrayRemove(tutorId) }
          : { favoriteTutorIds: arrayUnion(tutorId) };

        // setDoc with merge + arrayUnion/arrayRemove creates the doc if missing and reduces 404 retries
        await setDocFn(userRef, payload, { merge: true });

        if (isFavourite) {
          favoriteTutorIds.delete(tutorId);
        } else {
          favoriteTutorIds.add(tutorId);
        }
      } catch (error) {
        console.error('Unable to update favourite tutors', error);
        alert('Sorry, we could not update your favourites. Please try again.');
      } finally {
        favoriteMutations.delete(tutorId);
        refreshAllFavoriteButtons();
      }
    }

    if (typeof onAuth === 'function' && auth) {
      onAuth(auth, async (user) => {
        currentUser = user || null;
        if (currentUser) {
          await loadUserFavorites(currentUser.uid);
        } else {
          favoriteTutorIds = new Set();
          refreshAllFavoriteButtons();
        }
      });
    }

    function normalize(text) {
      return (text || '').toLowerCase();
    }

    function getInitials(text) {
      const source = (text || '').replace(/[^a-zA-Z\s]/g, ' ').trim();
      if (!source) return 'TU';
      const parts = source.split(/\s+/).filter(Boolean);
      const initials = parts.slice(0, 2).map((part) => part.charAt(0).toUpperCase()).join('');
      return initials || 'TU';
    }

    async function fetchPlaceDetails(placeId) {
      if (!functionsBase || !placeId) {
        return null;
      }
      if (placeCache.has(placeId)) {
        return placeCache.get(placeId);
      }
      if (inflightPlaces.has(placeId)) {
        return inflightPlaces.get(placeId);
      }

      const request = (async () => {
        try {
          const response = await fetch(`${functionsBase}/getPlaceDetails`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ placeId })
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.warn('Place lookup failed', placeId, errorText);
            return null;
          }

          const json = await response.json();
          placeCache.set(placeId, json);
          return json;
        } catch (error) {
          console.warn('Place lookup error', placeId, error);
          return null;
        } finally {
          inflightPlaces.delete(placeId);
        }
      })();

      inflightPlaces.set(placeId, request);
      const result = await request;
      if (!placeCache.has(placeId)) {
        placeCache.set(placeId, result);
      }
      return result;
    }

    async function hydratePlacesDetails(tutors) {
      if (!Array.isArray(tutors) || !functionsBase) {
        return;
      }
      const lookups = tutors.map(async (tutor) => {
        const settings = tutor?.placesSettings;
        if (!settings?.enabled || !settings.placeId) {
          return;
        }
        const details = await fetchPlaceDetails(settings.placeId);
        if (details) {
          tutor.placesSettings.lookup = details;
        }
      });
      await Promise.allSettled(lookups);
    }

    function createAvatar(tutor) {
      const avatar = document.createElement('div');
      avatar.className = 'tutor-card-avatar';
      const photoUrl = tutor.photoURL;

      if (photoUrl) {
        const img = document.createElement('img');
        img.src = photoUrl;
        img.alt = `${tutor.fullName || 'Tutor'} profile photo`;
        img.loading = 'lazy';
        avatar.appendChild(img);
      } else {
        const initialsEl = document.createElement('span');
        initialsEl.textContent = getInitials(tutor.fullName || tutor.headline || 'Tutor');
        avatar.appendChild(initialsEl);
      }

      return avatar;
    }

    function sanitizeHomeSlug(slug) {
      if (!slug) {
        return '';
      }
      const cleaned = String(slug).trim().toLowerCase().replace(/[^a-z0-9]+/g, '');
      return cleaned;
    }

    function buildTutorHomeUrl(slug) {
      const sanitized = sanitizeHomeSlug(slug);
      if (!sanitized) {
        return 'home.html';
      }
      return `home/${encodeURIComponent(sanitized)}/`;
    }

    function getTutorBioText(tutor) {
      return (tutor?.bio || tutor?.about || '').trim();
    }

    // Returns a trimmed first paragraph for the card dropdown.
    function buildBioPreview(rawBio) {
      if (!rawBio) {
        return '';
      }
      const segments = rawBio
        .split(/\n+/)
        .map((line) => line.trim())
        .filter(Boolean);
      const source = segments.length ? segments[0] : rawBio;
      if (source.length <= 320) {
        return source;
      }
      const truncated = source.slice(0, 317);
      const lastSpace = truncated.lastIndexOf(' ');
      const safeSlice = lastSpace > 240 ? truncated.slice(0, lastSpace) : truncated;
      return `${safeSlice.trim()}...`;
    }

    function buildBioElementId(tutor) {
      const base = String(tutor?.id || tutor?.slug || Date.now());
      const sanitized = base.replace(/[^a-zA-Z0-9_-]/g, '');
      return `tutor-bio-${sanitized || Math.random().toString(36).slice(2)}`;
    }

    function createBioSection(tutor, profileUrl) {
      const wrapper = document.createElement('div');
      wrapper.className = 'tutor-card-bio';
      wrapper.hidden = true;

      const rawBio = getTutorBioText(tutor);
      const preview = buildBioPreview(rawBio);

      const textEl = document.createElement('p');
      textEl.textContent = preview || 'This tutor has not added a biography yet.';
      wrapper.appendChild(textEl);

      if (profileUrl) {
        const readMoreLink = document.createElement('a');
        readMoreLink.href = profileUrl;
        readMoreLink.className = 'read-more-link';
        readMoreLink.textContent = 'Read more';
        wrapper.appendChild(readMoreLink);
      }

      return wrapper;
    }

    function matchesFilter(tutor, filters) {
      const queryMatch = !filters.query || [
        tutor.fullName,
        tutor.headline,
        ...(tutor.subjectsOffered || [])
      ].some((value) => normalize(value).includes(filters.query));

      if (!queryMatch) return false;

      const gradeMatch = !filters.grade || (tutor.gradeLevels || []).some((level) => normalize(level).includes(filters.grade));
      if (!gradeMatch) return false;

      const meetingModes = tutor.meetingModes || {};
      const supportsOnline = meetingModes.online || meetingModes.hybrid;
      const supportsInPerson = meetingModes.inPerson || meetingModes.hybrid;
      if (filters.meeting.online && !supportsOnline) return false;
      if (filters.meeting.inPerson && !supportsInPerson) return false;

      return true;
    }

    function renderTutors(tutors) {
      resultsGrid.innerHTML = '';
      favoriteButtons = new Map();
      tutors.forEach((tutor) => {
        const card = document.createElement('article');
        card.className = 'tutor-card';

        const header = document.createElement('div');
        header.className = 'tutor-card-header';

        header.appendChild(createAvatar(tutor));

        const headerBody = document.createElement('div');
        headerBody.className = 'tutor-card-header-body';

        const title = document.createElement('h2');
        title.textContent = tutor.fullName || 'Tutor';
        headerBody.appendChild(title);

        if (tutor.headline) {
          const headline = document.createElement('p');
          headline.className = 'headline';
          headline.textContent = tutor.headline;
          headerBody.appendChild(headline);
        }

        header.appendChild(headerBody);
        card.appendChild(header);

        const profileSlug = tutor.slug || '';
        const hasProfileSlug = Boolean(profileSlug);
        const publicUrl = hasProfileSlug
          ? buildTutorHomeUrl(profileSlug)
          : 'home.html';

        const bioSection = createBioSection(tutor, hasProfileSlug ? publicUrl : null);
        const bioId = buildBioElementId(tutor);
        bioSection.id = bioId;
        card.appendChild(bioSection);

        header.classList.add('toggleable');
        header.setAttribute('tabindex', '0');
        header.setAttribute('role', 'button');
        header.setAttribute('aria-expanded', 'false');
        header.setAttribute('aria-controls', bioId);

        const toggleBio = () => {
          const showBio = bioSection.hidden;
          bioSection.hidden = !showBio;
          header.setAttribute('aria-expanded', String(showBio));
          card.classList.toggle('bio-open', showBio);
        };

        header.addEventListener('click', toggleBio);
        header.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            toggleBio();
          }
        });

        const tagRow = document.createElement('div');
        tagRow.className = 'tag-row';

        const meetingModes = tutor.meetingModes || {};
        if (meetingModes.hybrid) {
          const hybridTag = document.createElement('span');
          hybridTag.className = 'tag';
          hybridTag.textContent = 'Online & In person';
          tagRow.appendChild(hybridTag);
        } else {
          if (meetingModes.online) {
            const tag = document.createElement('span');
            tag.className = 'tag';
            tag.textContent = 'Online';
            tagRow.appendChild(tag);
          }
          if (meetingModes.inPerson) {
            const tag = document.createElement('span');
            tag.className = 'tag';
            tag.textContent = 'In person';
            tagRow.appendChild(tag);
          }
        }

        if (tagRow.children.length > 0) {
          card.appendChild(tagRow);
        }

        if (tutor.subjectsOffered?.length) {
          const subjects = document.createElement('p');
          subjects.className = 'detail-text';
          subjects.innerHTML = `<strong>Subjects:</strong> ${tutor.subjectsOffered.join(', ')}`;
          card.appendChild(subjects);
        }

        if (tutor.gradeLevels?.length) {
          const grades = document.createElement('p');
          grades.className = 'detail-text';
          grades.innerHTML = `<strong>Grades:</strong> ${tutor.gradeLevels.join(', ')}`;
          card.appendChild(grades);
        }

        if (tutor.placesSettings?.enabled) {
          const placeDetails = tutor.placesSettings.lookup;
          const displayAddress = placeDetails?.formattedAddress || tutor.placesSettings.displayAddress;
          if (displayAddress) {
            const location = document.createElement('p');
            location.className = 'detail-text location-detail';

            const label = document.createElement('strong');
            label.textContent = 'Location:';
            location.appendChild(label);
            location.appendChild(document.createTextNode(` ${displayAddress}`));

            if (placeDetails?.mapsUrl) {
              location.appendChild(document.createElement('br'));
              const link = document.createElement('a');
              link.href = placeDetails.mapsUrl;
              link.target = '_blank';
              link.rel = 'noopener';
              link.textContent = 'View on Google Maps';
              location.appendChild(link);
            }

            card.appendChild(location);
          }
        }

        const profileLink = document.createElement('button');
        profileLink.type = 'button';
        profileLink.className = 'btn secondary';
        profileLink.textContent = 'View Profile';
        profileLink.addEventListener('click', () => {
          window.location.href = publicUrl;
        });

        const actionRow = document.createElement('div');
        actionRow.className = 'tutor-card-actions';
        actionRow.appendChild(createFavoriteButton(tutor.id));

        const bookButton = document.createElement('button');
        bookButton.type = 'button';
        bookButton.className = 'btn primary';
        bookButton.textContent = 'Book Session';
        bookButton.addEventListener('click', () => handleBookClick(tutor.id));
        actionRow.appendChild(bookButton);

        actionRow.appendChild(profileLink);

        card.appendChild(actionRow);

        resultsGrid.appendChild(card);
      });
      refreshAllFavoriteButtons();
    }

    function applyFilters() {
      const filters = {
        query: normalize(searchInput.value.trim()),
        grade: normalize(gradeInput.value.trim()),
        meeting: {
          online: filterOnline.checked,
          inPerson: filterInPerson.checked
        }
      };

      const filtered = allTutors.filter((tutor) => matchesFilter(tutor, filters));

      const hasResults = filtered.length > 0;
      resultsGrid.hidden = !hasResults;
      emptyState.hidden = hasResults;

      if (hasResults) {
        renderTutors(filtered);
      }

      void renderMap(filtered);
    }

    function clearMapOverlays() {
      markers.forEach((marker) => marker.setMap(null));
      circles.forEach((circle) => circle.setMap(null));
      markers = [];
      circles = [];
    }

    function updateCircleVisibility() {
      const shouldShowCircles = mapMode === 'radius';
      circles.forEach((circle) => circle.setMap(shouldShowCircles ? map : null));
    }

    async function renderMap(tutors) {
      lastMapTutors = Array.isArray(tutors) ? tutors : [];
      if (!mapContainer) {
        return;
      }
      try {
        if (!mapsApi) {
          mapsApi = await mapsApiPromise;
        }
      } catch (error) {
        mapError.hidden = false;
        mapError.textContent = 'Google Maps failed to load. Check your API key configuration.';
        console.error('Unable to load Google Maps', error);
        return;
      }

      if (!map) {
        map = new mapsApi.Map(mapContainer, {
          center: defaultCenter,
          zoom: 11,
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false
        });
        infoWindow = new mapsApi.InfoWindow();
        geocoder = new mapsApi.Geocoder();
      }

      clearMapOverlays();

      if (!Array.isArray(tutors) || tutors.length === 0) {
        map.setCenter(defaultCenter);
        map.setZoom(11);
        updateCircleVisibility();
        return;
      }

      const bounds = new mapsApi.LatLngBounds();
      let hasBounds = false;

      tutors.forEach((tutor) => {
        const travelInfo = tutor.travelInfo || tutor.tutorLocation || null;
        const lat = travelInfo?.location?.lat;
        const lng = travelInfo?.location?.lng;
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
          return;
        }

        const position = { lat, lng };
        hasBounds = true;
        bounds.extend(position);

        const marker = new mapsApi.Marker({
          map,
          position,
          title: tutor.fullName || travelInfo?.tutorName || 'Tutor'
        });
        markers.push(marker);

        const radiusKm = Number(travelInfo?.travelRadiusKm) || 0;
        if (radiusKm > 0) {
          const circle = new mapsApi.Circle({
            center: position,
            radius: radiusKm * 1000,
            strokeColor: '#38bdf8',
            strokeOpacity: 0.35,
            strokeWeight: 2,
            fillColor: '#38bdf8',
            fillOpacity: 0.15,
            map: mapMode === 'radius' ? map : null
          });
          circles.push(circle);
        }

        const subjects = Array.isArray(travelInfo?.subjects) && travelInfo.subjects.length
          ? travelInfo.subjects
          : (tutor.subjectsOffered || []);
        const address = travelInfo?.formattedAddress || travelInfo?.postalCode || '';

        const infoHtml = `
          <div style="min-width:220px;">
            <h3 style="margin:0 0 0.4rem 0; font-size:1.05rem; color:#0f172a;">${marker.getTitle()}</h3>
            ${subjects.length ? `<p style="margin:0 0 0.35rem 0;">Subjects: ${subjects.join(', ')}</p>` : ''}
            ${address ? `<p style=\"margin:0;\">${address}</p>` : ''}
          </div>
        `;

        marker.addListener('click', () => {
          infoWindow.setContent(infoHtml);
          infoWindow.open({ anchor: marker, map });
        });
      });

      updateCircleVisibility();

      if (hasBounds) {
        map.fitBounds(bounds, 60);
      } else {
        map.setCenter(defaultCenter);
        map.setZoom(11);
      }
    }

    async function centerMapOnPostalCode() {
      const queryValue = postalSearchInput.value.trim();
      if (!queryValue) {
        return;
      }
      try {
        if (!mapsApi) {
          mapsApi = await mapsApiPromise;
        }
        if (!map) {
          await renderMap(allTutors);
        }
        if (!geocoder) {
          geocoder = new mapsApi.Geocoder();
        }
        geocoder.geocode(
          { address: queryValue, componentRestrictions: { country: 'CA' } },
          (results, status) => {
            if (status === 'OK' && results[0]) {
              const result = results[0];
              if (result.geometry.viewport) {
                map.fitBounds(result.geometry.viewport);
              } else if (result.geometry.location) {
                map.setCenter(result.geometry.location);
                map.setZoom(12);
              }
              mapError.hidden = true;
              mapError.textContent = '';
            } else {
              mapError.hidden = false;
              mapError.textContent = 'Sorry, we could not find that postal code. Check the spelling and try again.';
            }
          }
        );
      } catch (error) {
        console.error('Postal code lookup failed', error);
        mapError.hidden = false;
        mapError.textContent = 'Unable to search that location right now. Please try again later.';
      }
    }

    async function loadTutors() {
      if (!db) {
        loadingState.textContent = '';
        errorState.hidden = false;
        errorState.textContent = 'Firestore is not configured. Check firebase-config.js setup.';
        return;
      }
      try {
        const tutorQuery = query(
          collection(db, 'tutorProfiles'),
          where('status', '==', 'published')
        );
        const tutorsCollection = collection(db, 'tutors');

        const [profileSnapshot, locationSnapshot] = await Promise.all([
          getDocs(tutorQuery),
          getDocs(tutorsCollection)
        ]);

        const locationById = new Map();
        locationSnapshot.forEach((docSnap) => {
          locationById.set(docSnap.id, docSnap.data());
        });

        allTutors = profileSnapshot.docs.map((docSnap) => ({
          id: docSnap.id,
          ...docSnap.data(),
          travelInfo: locationById.get(docSnap.id) || null
        }));
        allTutors.sort((a, b) => (a.fullName || '').localeCompare(b.fullName || ''));

        try {
          await hydratePlacesDetails(allTutors);
        } catch (error) {
          console.warn('Failed to hydrate Google Places details', error);
        }

        loadingState.textContent = '';
        loadingState.hidden = true;

        if (allTutors.length === 0) {
          resultsGrid.hidden = true;
          emptyState.hidden = false;
          void renderMap([]);
          return;
        }

        applyFilters();
      } catch (error) {
        console.error('Tutor search load error', error);
        loadingState.textContent = '';
        errorState.hidden = false;
        errorState.textContent = 'Unable to load tutors right now. Please refresh or try again later.';
      }
    }

    [searchInput, gradeInput, filterOnline, filterInPerson]
      .forEach((control) => {
        if (!control) return;
        const handler = () => applyFilters();
        if (control instanceof HTMLInputElement && control.type === 'text') {
          control.addEventListener('input', handler);
        } else {
          control.addEventListener('change', handler);
        }
      });

    mapDisplayRadios.forEach((radio) => {
      radio.addEventListener('change', () => {
        if (!radio.checked) {
          return;
        }
        mapMode = radio.value === 'radius' ? 'radius' : 'markers';
        updateCircleVisibility();
        if (mapMode === 'radius' && !map && lastMapTutors.length) {
          void renderMap(lastMapTutors);
        }
      });
    });

    if (postalSearchButton) {
      postalSearchButton.addEventListener('click', () => {
        void centerMapOnPostalCode();
      });
    }

    if (postalSearchInput) {
      postalSearchInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          void centerMapOnPostalCode();
        }
      });
    }

    loadTutors();
  </script>
</body>
</html>
